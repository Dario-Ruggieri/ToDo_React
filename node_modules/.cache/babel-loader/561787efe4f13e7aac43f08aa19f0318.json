{"ast":null,"code":"var _jsxFileName = \"/home/dario/Scrivania/ToDo_React_Github/ToDo_React/src/components/Form.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Form(props) {\n  _s();\n  // Ogni componente permette di tracciare alcuni dati del componente stesso\n  // In questo caso si vuole tracciare l'input. Per il tracciamento, React\n  // mette a disposizione il tool state. Lo state è caratterizzato da una \n  // serie di funzioni che vengono chimate hook\n  const [name, setName] = useState('');\n  //Qua abbiamo una variabile name, che ha come valore iniziale \"Use hooks!\"\n  //e una funzione setName che permette di cambiare name. Io voglio gestire il\n  //cambiamento dell'input. Per questo motivo vado ad assegnare all'input il valore\n  //name, nel seguente modo value={name}\n  function handleSubmit(e) {\n    e.preventDefault();\n    props.addTask(name); //Utilizzo la funzione addTask che è stata\n    //passata come parametro dal componente App\n    setName(''); //Una volta preso il valore, svuoto l'input\n  }\n\n  function handleChange(e) {\n    // Ogni volta che scrivo qualcosa nell'input, quindi cambia qualcosa\n    // viene chiamata questa funzione dove e rappresenta l'elemento che è cambiato\n    // con e.target.value è quindi possibile avere il valore dell'elemento, ovvero\n    // dell'input. Facendo setName(e.target.value) faccio si che il form contenga e visualizzi\n    // ciò che sto inserendo. Ricordiamo, infatti, che setName gestisce il valore che viene\n    // visualizzato dell'input\n    setName(e.target.value);\n  }\n  return /*#__PURE__*/_jsxDEV(\"form\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"What needs to be done?\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"text\",\n      placeholder: \"Add a new ToDo\",\n      value: name,\n      onChange: handleChange\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      type: \"submit\",\n      onClick: handleSubmit,\n      children: \"Add\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 29,\n    columnNumber: 9\n  }, this);\n}\n_s(Form, \"/PAWDgWx7+Y6BmsFMUKcdrcX5eM=\");\n_c = Form;\nexport default Form;\nvar _c;\n$RefreshReg$(_c, \"Form\");","map":{"version":3,"names":["React","useState","Form","props","name","setName","handleSubmit","e","preventDefault","addTask","handleChange","target","value"],"sources":["/home/dario/Scrivania/ToDo_React_Github/ToDo_React/src/components/Form.js"],"sourcesContent":["import React, { useState } from \"react\";\n\nfunction Form(props){\n    // Ogni componente permette di tracciare alcuni dati del componente stesso\n    // In questo caso si vuole tracciare l'input. Per il tracciamento, React\n    // mette a disposizione il tool state. Lo state è caratterizzato da una \n    // serie di funzioni che vengono chimate hook\n    const [name, setName] = useState('');\n    //Qua abbiamo una variabile name, che ha come valore iniziale \"Use hooks!\"\n    //e una funzione setName che permette di cambiare name. Io voglio gestire il\n    //cambiamento dell'input. Per questo motivo vado ad assegnare all'input il valore\n    //name, nel seguente modo value={name}\n    function handleSubmit(e) {\n        e.preventDefault();\n        props.addTask(name); //Utilizzo la funzione addTask che è stata\n        //passata come parametro dal componente App\n        setName(''); //Una volta preso il valore, svuoto l'input\n      }\n    function handleChange(e){\n        // Ogni volta che scrivo qualcosa nell'input, quindi cambia qualcosa\n        // viene chiamata questa funzione dove e rappresenta l'elemento che è cambiato\n        // con e.target.value è quindi possibile avere il valore dell'elemento, ovvero\n        // dell'input. Facendo setName(e.target.value) faccio si che il form contenga e visualizzi\n        // ciò che sto inserendo. Ricordiamo, infatti, che setName gestisce il valore che viene\n        // visualizzato dell'input\n        setName(e.target.value);\n    }\n    return(\n        <form>\n            <h2>\n                What needs to be done?\n            </h2>\n            <input type=\"text\" placeholder=\"Add a new ToDo\" value={name}\n            onChange={handleChange}></input>\n            <button type=\"submit\" onClick={handleSubmit}>Add</button> \n            {/* Nel momento in cui clicco il bottone ho un evento, che mi \n            andrà a cambiare un altro componente:App\n            Non è però possibile passare dati da un child ad un parent (cosa che\n            invece è possibile da parent a child), come in questo\n            caso. Possiamo però scrivere una funzione nel componente App in modo tale\n            che si aspetti dei dati da Form. Passiamo quindi questa funzione come prop\n            a Form --> callback prop */}\n        </form>\n    )\n}\nexport default Form;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AAAC;AAExC,SAASC,IAAI,CAACC,KAAK,EAAC;EAAA;EAChB;EACA;EACA;EACA;EACA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGJ,QAAQ,CAAC,EAAE,CAAC;EACpC;EACA;EACA;EACA;EACA,SAASK,YAAY,CAACC,CAAC,EAAE;IACrBA,CAAC,CAACC,cAAc,EAAE;IAClBL,KAAK,CAACM,OAAO,CAACL,IAAI,CAAC,CAAC,CAAC;IACrB;IACAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;EACf;;EACF,SAASK,YAAY,CAACH,CAAC,EAAC;IACpB;IACA;IACA;IACA;IACA;IACA;IACAF,OAAO,CAACE,CAAC,CAACI,MAAM,CAACC,KAAK,CAAC;EAC3B;EACA,oBACI;IAAA,wBACI;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAEK,eACL;MAAO,IAAI,EAAC,MAAM;MAAC,WAAW,EAAC,gBAAgB;MAAC,KAAK,EAAER,IAAK;MAC5D,QAAQ,EAAEM;IAAa;MAAA;MAAA;MAAA;IAAA,QAAS,eAChC;MAAQ,IAAI,EAAC,QAAQ;MAAC,OAAO,EAAEJ,YAAa;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAAa;EAAA;IAAA;IAAA;IAAA;EAAA,QAQtD;AAEf;AAAC,GA1CQJ,IAAI;AAAA,KAAJA,IAAI;AA2Cb,eAAeA,IAAI;AAAC;AAAA"},"metadata":{},"sourceType":"module"}